You actually shipped fine — Vite built your client into dist/public/ and bundled your Node server into dist/index.js.
On Vercel, because there’s no config telling it which folder is the static site, it’s serving the JS bundle at the root (so you see raw transpiled code on /). ✅ Build OK, ❌ wrong output picked.

Fix (fastest)

Tell Vercel the site lives in dist/public and let it SPA-fallback to index.html.
	1.	Add vercel.json at the repo root:

{
  "buildCommand": "npm run build",
  "outputDirectory": "dist/public",
  "rewrites": [
    { "source": "/api/(.*)", "destination": "/api/$1" }
  ],
  "routes": [
    { "src": "/(.*)", "dest": "/index.html" }
  ]
}

	•	outputDirectory makes Vercel serve dist/public/index.html instead of dist/index.js.
	•	routes gives a SPA fallback (React Router, etc.).

	2.	(Optional but cleaner) Change your Vite outDir back to the default and keep Vercel in sync:

	•	In vite.config.ts set:

build: { outDir: 'dist' }


	•	Then update vercel.json outputDirectory to "dist".

⸻

About your Express server

Vercel won’t run your long-lived express() in dist/index.js. If you need /api/contact, make it a Vercel Function instead of Express.

Create /api/contact.ts (serverless):

import type { VercelRequest, VercelResponse } from '@vercel/node';
import { z } from 'zod';
import { MailService } from '@sendgrid/mail';

const bodySchema = z.object({
  name: z.string().min(1),
  email: z.string().email(),
  company: z.string().optional(),
  message: z.string().min(5),
  website: z.string().optional() // honeypot
});

const mail = new MailService();
if (process.env.SENDGRID_API_KEY) mail.setApiKey(process.env.SENDGRID_API_KEY);

export default async function handler(req: VercelRequest, res: VercelResponse) {
  if (req.method !== 'POST') return res.status(405).json({ ok: false, message: 'Method not allowed' });

  const parsed = bodySchema.safeParse(req.body);
  if (!parsed.success) return res.status(400).json({ ok: false, message: 'Invalid form data', errors: parsed.error.errors });

  const { name, email, company, message, website } = parsed.data;
  if (website && website.trim() !== '') return res.status(200).json({ ok: true }); // bot trap

  // TODO: save to DB (Neon) if you want — use serverless-friendly client (@neondatabase/serverless)

  if (process.env.SENDGRID_API_KEY) {
    try {
      await mail.send({
        to: process.env.CONTACT_TO_EMAIL || 'hello@metrixmedia.com',
        from: process.env.CONTACT_FROM_EMAIL || 'noreply@metrixmedia.com',
        subject: `New Contact Form Submission from ${name}`,
        text: `Name: ${name}\nEmail: ${email}\nCompany: ${company || 'N/A'}\n\n${message}`
      });
    } catch (e) { /* swallow & continue */ }
  }

  return res.json({ ok: true, message: "Thank you for your message! We'll get back to you soon." });
}

Then remove the Express bits from your build script, so package.json build is just:

"build": "vite build"

(You don’t need esbuild server/index.ts anymore for Vercel.)

⸻

TL;DR
	•	The “raw JS on the page” is because Vercel served dist/index.js.
	•	Point Vercel to your client folder via vercel.json → outputDirectory: "dist/public" (or switch your Vite outDir to dist and match it).
	•	Convert any API routes to Vercel Functions instead of Express.

If you want, paste your vite.config.ts + package.json here and I’ll tailor the exact minimal edits.