Yep — you’re still shipping the server bundle and Vercel is serving it. Your build log shows:

> vite build && esbuild server/index.ts --platform=node --packages=external --bundle --format=esm --outdir=dist

That second half produces dist/index.js (your Express bundle). Because it exists, Vercel happily picks it up and you end up seeing that var __defProp = ... blob in the browser.

Here’s the quick, surgical fix. Do exactly these diffs and it’ll serve your React app instead of the server file.

⸻

1) Stop building the server on Vercel

package.json

{
  "scripts": {
-   "build": "vite build && esbuild server/index.ts --platform=node --packages=external --bundle --format=esm --outdir=dist",
+   "build": "vite build"
  }
}

If you don’t need a Node server on Vercel, you’re done with server bundling. (If you do need an API, convert it to a Vercel Function under /api—see step 4.)

⸻

2) Point Vercel squarely at the client output

You currently build the client to dist/public (from your vite.config.ts). Tell Vercel to serve that only and to SPA-fallback to index.html.

vercel.json (at repo root)

{
  "buildCommand": "npm run build",
  "outputDirectory": "dist/public",
  "rewrites": [
    { "source": "/((?!api/).*)", "destination": "/index.html" }
  ]
}

The negative look-ahead keeps space for /api/* routes later.
If you have no API, this form still works fine.

Vercel Project Settings → Build & Output
	•	Framework Preset: Vite (or “Other”)
	•	Build Command: npm run build
	•	Output Directory: dist/public
(Make sure this matches the vercel.json. If you set something different in the dashboard, it overrides vercel.json.)

⸻

3) (Optional) Simplify Vite outDir

If you’d rather use the default dist:

vite.config.ts

  build: {
-   outDir: path.resolve(import.meta.dirname, "dist/public"),
+   outDir: path.resolve(import.meta.dirname, "dist"),
    emptyOutDir: true
  },

Then change vercel.json:

- "outputDirectory": "dist/public",
+ "outputDirectory": "dist",

Either approach is fine — just keep Vercel and Vite in agreement.

⸻

4) If you need /api/contact, use a Vercel Function (no Express)

Create /api/contact.ts:

import type { VercelRequest, VercelResponse } from '@vercel/node';
import { z } from 'zod';
import { MailService } from '@sendgrid/mail';

const schema = z.object({
  name: z.string().min(1),
  email: z.string().email(),
  company: z.string().optional(),
  message: z.string().min(5),
  website: z.string().optional() // honeypot
});

const mail = new MailService();
if (process.env.SENDGRID_API_KEY) mail.setApiKey(process.env.SENDGRID_API_KEY!);

export default async function handler(req: VercelRequest, res: VercelResponse) {
  if (req.method !== 'POST') return res.status(405).json({ ok:false, message:'Method not allowed' });

  const parsed = schema.safeParse(req.body);
  if (!parsed.success) return res.status(400).json({ ok:false, message:'Invalid form data', errors: parsed.error.errors });

  const { name, email, company, message, website } = parsed.data;
  if (website && website.trim()) return res.json({ ok:true }); // bot trap

  // OPTIONAL: save to Neon/Drizzle here (works on serverless)
  if (process.env.SENDGRID_API_KEY) {
    try {
      await mail.send({
        to: process.env.CONTACT_TO_EMAIL || 'hello@metrixmedia.com',
        from: process.env.CONTACT_FROM_EMAIL || 'noreply@metrixmedia.com',
        subject: `New Contact Form Submission from ${name}`,
        text: `Name: ${name}\nEmail: ${email}\nCompany: ${company ?? 'N/A'}\n\n${message}`
      });
    } catch {}
  }

  res.json({ ok:true, message:"Thank you for your message! We'll get back to you soon." });
}

No express(), no server/index.ts, no esbuild step.

⸻

5) Clean redeploy checklist
	•	Commit the package.json change (no server build).
	•	Ensure vercel.json exists and is committed.
	•	In Vercel dashboard, confirm Output Directory equals your Vite outDir.
	•	Trigger a new deploy.

⸻

Why you were still seeing the blob

As long as dist/index.js is produced, Vercel can treat it as an artifact to serve. Removing the server build step eliminates that file, so the only thing left to serve is dist/public/index.html (or dist/index.html if you switch), and your app renders normally.

If you want me to double-check, paste your current package.json and vercel.json (after edits) and I’ll spot any stragglers in one pass.